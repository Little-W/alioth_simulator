已根据要求修改：删除了“示例验证”部分，并对“每次操作完成后执行如下移位逻辑”处的表达进行了数学公式标准化处理。以下是修改后的内容：

---

### 3.X 乘法器设计

本节介绍处理器中乘法指令（`MUL`、`MULH`、`MULHSU`、`MULHU`）的实现方式。为在有限的硬件资源下实现有符号及无符号乘法的支持，本设计采用基4的Booth编码算法实现多周期乘法器。该方案在面积与时序之间取得较好的平衡，具备良好的可综合性与可扩展性。

#### 3.X.1 设计原理

基4 Booth算法的核心思想是通过3位窗口对乘数进行编码，每次迭代计算2位乘积并移位2位，从而在降低迭代次数的同时减少冗余操作。设乘数与被乘数分别为 \$A\$ 与 \$B\$，其中 \$A\$ 被扩展为奇数位长以适配Booth编码规则：

$$
A = a_{2n+1}a_{2n}\cdots a_1 a_0 a_{-1}
$$

$$
B = b_{n-1}b_{n-2}\cdots b_0
$$

其中 \$a\_{-1} = 0\$，\$a\_{2n+1}, a\_{2n}\$ 为符号扩展位。将 \$A\$ 按3位滑动窗口进行编码，可将乘积表示为：

$$
AB = B \times \sum_{k=0}^{n} \left(a_{2k+1} + a_{2k} - 2a_{2k-1}\right) \cdot 2^{2k}
$$

每组 \$(a\_{2k+1}, a\_{2k}, a\_{2k-1})\$ 对应于一组Booth操作，其含义见下表：

| 编码位 | 运算操作 |
| --- | ---- |
| 000 | 0    |
| 001 | +B   |
| 010 | +B   |
| 011 | +2B  |
| 100 | -2B  |
| 101 | -B   |
| 110 | -B   |
| 111 | 0    |

该算法的优势在于将乘法操作转化为有限次加法与减法，并减少所需移位次数，从而有效降低周期数。

#### 3.X.2 状态机设计与操作流程

乘法器采用三状态有限状态机（FSM）实现控制流程，包括如下三种状态：

* **IDLE 状态**
  在该状态下，乘法器等待 `start_i` 信号拉高。当启动信号有效时，模块开始加载乘数、被乘数与操作类型，并初始化部分积寄存器 `p_reg` 及相关 Booth 操作数（+B、-B、+2B、-2B）。同时，将计数器清零，为后续迭代做准备，状态转移至 CALC。

* **CALC 状态**
  该状态执行基4 Booth 算法的核心迭代过程。每轮迭代依据 `p_reg` 的最低三位选择相应加权操作，并执行一次带符号的右移2位操作。每轮迭代可处理乘数的2位，共需16轮以完成32位乘法。迭代计数器满 16 后状态转移至 OUTPUT。

* **OUTPUT 状态**
  在此状态，根据指令类型选择输出结果。例如 `MUL` 指令返回乘积低32位，`MULH` 返回高32位，而 `MULHSU` 与 `MULHU` 则在返回高位乘积的基础上执行符号修正。输出完成后，`ready_o` 信号拉高，模块回到 IDLE 状态。


**计算周期分析**

一次乘法指令的完整处理流程包含：

* 初始化阶段（IDLE）：1 个周期；
* Booth 迭代计算（CALC）：16 个周期，每轮处理2位乘数；
* 结果输出阶段（OUTPUT）：1 个周期。

因此，基于基4 Booth 编码的多周期乘法器在当前设计中共需 **18 个时钟周期** 完成一次乘法运算。


#### 3.X.3 RTL实现细节

硬件实现中，为提高并行度与减少临时计算重复，设计中预先计算了四种加权被乘数：`+B`、`-B`、`+2B`、`-2B`，用于在 `CALC` 状态中快速选择运算路径。部分积寄存器 \$P\$ 包含完整运算状态，每轮更新如下：

$$
P^{(k+1)} = \mathrm{SAR}_2 \left( P^{(k)} + \Delta_k \right)
$$

其中 \$\Delta\_k\$ 表示当前Booth编码下的操作数（可能为 \$0, \pm B, \pm 2B\$），\$\mathrm{SAR}\_2(\cdot)\$ 表示带符号算术右移2位操作。

最终，在 `OUTPUT` 状态中，根据 `op_i` 决定返回结果的高位或低位，并对混合符号乘法进行符号修正：

* 若被乘数为负且为无符号乘法，需加回 \$2^{32} \cdot B\$；
* 若乘数为负且为无符号乘法，需加回 \$2^{32} \cdot A\$。

修正逻辑通过符号位判断实现，在硬件上以加法形式进行补偿，确保计算结果的正确性。
