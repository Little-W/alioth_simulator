/*
 * Copyright (c) 2006-2019, RT-Thread Development Team
 *
 * SPDX-License-Identifier: Apache-2.0
 *
 * Change Logs:
 * Date           Author       Notes
 * 2021-05-24                  the first version
 */

#include <rthw.h>
#include <rtthread.h>
#include "board.h"
#include "cpuport.h"

#define SYSTICK_TICK_CONST (SOC_TIMER_FREQ / RT_TICK_PER_SECOND)
#define RT_KERNEL_INTERRUPT_LEVEL 1

#ifdef RT_USING_CONSOLE
#include "uart.h"

int nano_uart_init(void);
char rt_hw_console_getchar(void);

/* 补充 uart_irq_handler 声明 */
void uart_irq_handler(void *param);
#endif

/** _end symbol defined in linker script*/
extern void *_end;
/** _heap_end symbol defined in linker script*/
extern void *_heap_end;
#define HEAP_BEGIN &_end
#define HEAP_END &_heap_end

void timer_irq_handler(int vector, void *param);
void swi_handler(int vector, void *param);

static void plic_dispatch_wrapper(int vector, void *param)
{
    plic_dispatch();
}

void rt_hw_ticksetup(void)
{
    uint64_t ticks = SYSTICK_TICK_CONST;
    SysTick_Config(ticks);
    rt_hw_interrupt_install(MachineTimer_IRQn, timer_irq_handler, RT_NULL, "timerirq");
    __enable_timer_irq();
}

void swi_handler(int vector, void *param)
{
    CLINT_ClearSWIRQ();
}

void timer_irq_handler(int vector, void *param)
{
    SysTick_Reload(SYSTICK_TICK_CONST);
    rt_tick_increase();
}

/**
 * @brief Setup hardware board for rt-thread
 *
 */
void rt_hw_board_init(void)
{
    rt_hw_interrupt_init();
    rt_hw_ticksetup();

    rt_hw_interrupt_install(MachineSoftware_IRQn, swi_handler, RT_NULL, "swi");
    __enable_sw_irq();
    plic_init();
    __enable_ext_irq();
    rt_hw_interrupt_install(MachineExternal_IRQn, plic_dispatch_wrapper, RT_NULL, "plic");

    gpio_enable_output(GPIO0, 0xFFFFFFFF); // Enable all GPIO0 pins as output
    gpio_write(GPIO0, 0xFFFFFFFF, 0); // Set all GPIO0 pins low

#ifdef RT_USING_CONSOLE
    nano_uart_init();
#endif

#if defined(RT_USING_CONSOLE) && defined(RT_USING_DEVICE)
    rt_console_set_device(RT_CONSOLE_DEVICE_NAME);
#endif

#ifdef RT_USING_COMPONENTS_INIT
    rt_components_board_init();
#endif

#if defined(RT_USING_USER_MAIN) && defined(RT_USING_HEAP)
    rt_system_heap_init((void *)HEAP_BEGIN, (void *)HEAP_END);
#endif
}

#ifdef RT_USING_CONSOLE
#define CONSOLE_UART UART0
#define CONSOLE_UART_IRQn UART0_IRQn // 补充中断号定义

/* 补充 ringbuffer 结构体定义 */
struct rt_ringbuffer
{
    rt_uint8_t *buffer_ptr;

    rt_uint16_t read_mirror : 1;
    rt_uint16_t read_index : 15;
    rt_uint16_t write_mirror : 1;
    rt_uint16_t write_index : 15;

    rt_int16_t buffer_size;
};

/* ringbuffer 实现部分 */
#define UART_RX_BUF_LEN 64
static rt_uint8_t uart_rx_buf[UART_RX_BUF_LEN];
static struct rt_ringbuffer uart_rxcb;
static struct rt_semaphore shell_rx_sem;

/* ringbuffer 相关函数 */
static rt_size_t rb_data_len(struct rt_ringbuffer *rb)
{
    if (rb->read_index == rb->write_index)
        return rb->read_mirror == rb->write_mirror ? 0 : rb->buffer_size;
    return rb->write_index > rb->read_index ?
        rb->write_index - rb->read_index :
        rb->buffer_size - (rb->read_index - rb->write_index);
}

static rt_size_t rb_space_len(struct rt_ringbuffer *rb)
{
    return rb->buffer_size - rb_data_len(rb);
}

static void rb_init(struct rt_ringbuffer *rb, rt_uint8_t *pool, rt_int16_t size)
{
    rb->read_mirror = rb->read_index = 0;
    rb->write_mirror = rb->write_index = 0;
    rb->buffer_ptr = pool;
    rb->buffer_size = size;
}

static rt_size_t rb_putchar(struct rt_ringbuffer *rb, rt_uint8_t ch)
{
    if (!rb_space_len(rb)) return 0;
    rb->buffer_ptr[rb->write_index] = ch;
    if (rb->write_index == rb->buffer_size - 1)
    {
        rb->write_mirror = ~rb->write_mirror;
        rb->write_index = 0;
    }
    else rb->write_index++;
    return 1;
}

static rt_size_t rb_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch)
{
    if (!rb_data_len(rb)) return 0;
    *ch = rb->buffer_ptr[rb->read_index];
    if (rb->read_index == rb->buffer_size - 1)
    {
        rb->read_mirror = ~rb->read_mirror;
        rb->read_index = 0;
    }
    else rb->read_index++;
    return 1;
}

/* UART 初始化，增加 ringbuffer 和信号量初始化 */
int nano_uart_init(void)
{
    uart_init(CONSOLE_UART, 115200);
    uart_config_stopbit(CONSOLE_UART, UART_STOP_BIT_1);
    uart_disable_paritybit(CONSOLE_UART);

    rb_init(&uart_rxcb, uart_rx_buf, UART_RX_BUF_LEN);
    rt_sem_init(&shell_rx_sem, "shell_rx", 0, 0);

    // 补充中断相关配置，参考 HAL 驱动
    plic_enable_irq(CONSOLE_UART_IRQn); // 使能UART中断
    plic_set_priority(CONSOLE_UART_IRQn, 2); // 设置优先级
    plic_set_handler(CONSOLE_UART_IRQn, uart_irq_handler, RT_NULL); // 注册中断处理函数
    uart_set_rx_th(CONSOLE_UART, UART_RX_FIFO_TH_1BYTE); // 设置接收FIFO中断触发等级为1字节
    uart_enable_rx_th_int(CONSOLE_UART); // 使能接收中断

    return 0;
}
// INIT_BOARD_EXPORT(nano_uart_init);

void rt_hw_console_output(const char *str)
{
    rt_size_t i = 0, size = 0;
    char a = '\r';
    size = rt_strlen(str);
    for (i = 0; i < size; i++)
    {
        if (*(str + i) == '\n')
        {
            uart_write(CONSOLE_UART, (uint8_t)a);
        }
        uart_write(CONSOLE_UART, (uint8_t)*(str + i));
    }
}

/* UART 中断处理函数，接收数据写入 ringbuffer 并释放信号量 */
void uart_irq_handler(void *param)
{
    int ch = -1;
    rt_base_t level;
    level = rt_hw_interrupt_disable();
    while (UART0->LSR & 0x1)
    {
        ch = uart_read(UART0);
        if (ch != -1)
        {
            rb_putchar(&uart_rxcb, (rt_uint8_t)ch);
        }
        else break;
    }
    rt_hw_interrupt_enable(level);
    rt_sem_release(&shell_rx_sem);
}

/* 控制台输入函数，等待 ringbuffer 有数据 */
char rt_hw_console_getchar(void)
{
    char ch = 0;
    while (rb_getchar(&uart_rxcb, (rt_uint8_t *)&ch) != 1)
    {
        rt_sem_take(&shell_rx_sem, RT_WAITING_FOREVER);
    }
    return ch;
}
#endif